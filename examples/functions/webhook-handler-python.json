{
  "name": "webhook-handler-python",
  "description": "Generic webhook handler with signature verification, payload parsing, and forwarding",
  "runtime": "python3.11",
  "handler": "handler.handle",
  "memory_mb": 256,
  "timeout_sec": 30,
  "code": "import hashlib\nimport hmac\nimport json\nimport base64\nimport urllib.request\nimport urllib.parse\nimport time\n\ndef handle(event, context):\n    \"\"\"Generic webhook handler.\n    \n    Parameters:\n    - payload: The webhook payload (required)\n    - headers: HTTP headers from the webhook request\n    - config: Configuration object\n      - secret: Secret key for signature verification\n      - signature_header: Header containing the signature\n      - signature_algo: Algorithm (sha256, sha1, md5)\n      - signature_prefix: Prefix to strip (e.g., 'sha256=')\n      - forward_url: URL to forward the webhook to\n      - transform: Field mapping for transformation\n      - filters: Conditions to filter webhooks\n    \"\"\"\n    payload = event.get('payload', {})\n    headers = event.get('headers', {})\n    config = event.get('config', {})\n    \n    result = {\n        'received_at': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),\n        'verified': False,\n        'processed': False,\n        'forwarded': False\n    }\n    \n    # Signature verification\n    secret = config.get('secret')\n    sig_header = config.get('signature_header', 'X-Signature')\n    sig_algo = config.get('signature_algo', 'sha256')\n    sig_prefix = config.get('signature_prefix', '')\n    \n    if secret:\n        provided_sig = headers.get(sig_header, '')\n        if sig_prefix and provided_sig.startswith(sig_prefix):\n            provided_sig = provided_sig[len(sig_prefix):]\n        \n        payload_bytes = json.dumps(payload, separators=(',', ':')).encode('utf-8')\n        \n        if sig_algo == 'sha256':\n            computed_sig = hmac.new(secret.encode(), payload_bytes, hashlib.sha256).hexdigest()\n        elif sig_algo == 'sha1':\n            computed_sig = hmac.new(secret.encode(), payload_bytes, hashlib.sha1).hexdigest()\n        elif sig_algo == 'md5':\n            computed_sig = hmac.new(secret.encode(), payload_bytes, hashlib.md5).hexdigest()\n        else:\n            computed_sig = ''\n        \n        result['verified'] = hmac.compare_digest(provided_sig.lower(), computed_sig.lower())\n        \n        if not result['verified']:\n            return {\n                \"statusCode\": 401,\n                \"body\": {\n                    **result,\n                    \"error\": \"Invalid signature\"\n                }\n            }\n    else:\n        result['verified'] = True  # No verification required\n    \n    # Apply filters\n    filters = config.get('filters', [])\n    for f in filters:\n        field = f.get('field')\n        operator = f.get('op', 'eq')\n        value = f.get('value')\n        \n        # Navigate nested fields\n        field_value = payload\n        for part in field.split('.'):\n            if isinstance(field_value, dict):\n                field_value = field_value.get(part)\n            else:\n                field_value = None\n                break\n        \n        passed = False\n        if operator == 'eq': passed = field_value == value\n        elif operator == 'ne': passed = field_value != value\n        elif operator == 'in': passed = field_value in value\n        elif operator == 'contains': passed = value in str(field_value)\n        elif operator == 'exists': passed = field_value is not None\n        elif operator == 'regex':\n            import re\n            passed = bool(re.search(value, str(field_value)))\n        \n        if not passed:\n            return {\n                \"statusCode\": 200,\n                \"body\": {\n                    **result,\n                    \"filtered\": True,\n                    \"filter_reason\": f\"Field '{field}' did not match condition\"\n                }\n            }\n    \n    result['processed'] = True\n    \n    # Transform payload\n    transform = config.get('transform', {})\n    transformed_payload = {}\n    \n    if transform:\n        for target_field, source_path in transform.items():\n            value = payload\n            for part in source_path.split('.'):\n                if isinstance(value, dict):\n                    value = value.get(part)\n                else:\n                    value = None\n                    break\n            transformed_payload[target_field] = value\n    else:\n        transformed_payload = payload\n    \n    # Forward webhook\n    forward_url = config.get('forward_url')\n    if forward_url:\n        try:\n            data = json.dumps(transformed_payload).encode('utf-8')\n            req = urllib.request.Request(\n                forward_url,\n                data=data,\n                headers={\n                    'Content-Type': 'application/json',\n                    'User-Agent': 'Nimbus-Webhook-Handler/1.0',\n                    'X-Forwarded-From': 'nimbus-webhook-handler'\n                },\n                method='POST'\n            )\n            \n            with urllib.request.urlopen(req, timeout=10) as response:\n                result['forwarded'] = True\n                result['forward_status'] = response.status\n                \n        except Exception as e:\n            result['forward_error'] = str(e)\n    \n    return {\n        \"statusCode\": 200,\n        \"body\": {\n            **result,\n            \"payload\": transformed_payload,\n            \"original_payload\": payload if transform else None\n        }\n    }"
}
