{
  "name": "api-aggregator-node",
  "description": "Aggregate data from multiple API endpoints with parallel requests and result merging",
  "runtime": "nodejs20",
  "handler": "index.handler",
  "memory_mb": 256,
  "timeout_sec": 60,
  "code": "const https = require('https');\nconst http = require('http');\nconst { URL } = require('url');\n\nexports.handler = async (event, context) => {\n    const { requests = [], options = {} } = event;\n    \n    if (!requests.length) {\n        return {\n            statusCode: 400,\n            body: { error: 'requests array is required' }\n        };\n    }\n    \n    const {\n        parallel = true,\n        timeout = 30000,\n        continueOnError = true,\n        mergeStrategy = 'object' // 'object', 'array', 'first', 'custom'\n    } = options;\n    \n    const fetchUrl = (config) => {\n        return new Promise((resolve, reject) => {\n            const startTime = Date.now();\n            const {\n                url,\n                method = 'GET',\n                headers = {},\n                body,\n                name,\n                transform\n            } = config;\n            \n            const parsedUrl = new URL(url);\n            const isHttps = parsedUrl.protocol === 'https:';\n            const client = isHttps ? https : http;\n            \n            const requestOptions = {\n                hostname: parsedUrl.hostname,\n                port: parsedUrl.port || (isHttps ? 443 : 80),\n                path: parsedUrl.pathname + parsedUrl.search,\n                method,\n                headers: {\n                    'User-Agent': 'Nimbus-Function/1.0',\n                    ...headers\n                },\n                timeout\n            };\n            \n            if (body && typeof body === 'object') {\n                requestOptions.headers['Content-Type'] = 'application/json';\n            }\n            \n            const req = client.request(requestOptions, (res) => {\n                let data = '';\n                res.on('data', chunk => data += chunk);\n                res.on('end', () => {\n                    let parsedData;\n                    try {\n                        parsedData = JSON.parse(data);\n                    } catch {\n                        parsedData = data;\n                    }\n                    \n                    // Apply transform if specified\n                    if (transform) {\n                        try {\n                            const transformFn = new Function('data', 'response', `return ${transform}`);\n                            parsedData = transformFn(parsedData, { status: res.statusCode, headers: res.headers });\n                        } catch (e) {\n                            // Keep original data if transform fails\n                        }\n                    }\n                    \n                    resolve({\n                        name: name || url,\n                        success: res.statusCode >= 200 && res.statusCode < 300,\n                        status: res.statusCode,\n                        data: parsedData,\n                        headers: res.headers,\n                        elapsed_ms: Date.now() - startTime\n                    });\n                });\n            });\n            \n            req.on('error', (e) => {\n                resolve({\n                    name: name || url,\n                    success: false,\n                    error: e.message,\n                    elapsed_ms: Date.now() - startTime\n                });\n            });\n            \n            req.on('timeout', () => {\n                req.destroy();\n                resolve({\n                    name: name || url,\n                    success: false,\n                    error: 'Request timeout',\n                    elapsed_ms: Date.now() - startTime\n                });\n            });\n            \n            if (body) {\n                req.write(typeof body === 'object' ? JSON.stringify(body) : body);\n            }\n            req.end();\n        });\n    };\n    \n    const startTime = Date.now();\n    let results;\n    \n    if (parallel) {\n        results = await Promise.all(requests.map(fetchUrl));\n    } else {\n        results = [];\n        for (const req of requests) {\n            const result = await fetchUrl(req);\n            results.push(result);\n            if (!result.success && !continueOnError) break;\n        }\n    }\n    \n    // Merge results based on strategy\n    let merged;\n    const successfulResults = results.filter(r => r.success);\n    \n    switch (mergeStrategy) {\n        case 'array':\n            merged = successfulResults.map(r => r.data);\n            break;\n        case 'first':\n            merged = successfulResults[0]?.data || null;\n            break;\n        case 'object':\n        default:\n            merged = {};\n            successfulResults.forEach(r => {\n                merged[r.name] = r.data;\n            });\n            break;\n    }\n    \n    const totalElapsed = Date.now() - startTime;\n    const successCount = successfulResults.length;\n    const failureCount = results.length - successCount;\n    \n    return {\n        statusCode: failureCount === results.length ? 502 : 200,\n        body: {\n            merged,\n            results,\n            metadata: {\n                total_requests: results.length,\n                successful: successCount,\n                failed: failureCount,\n                parallel,\n                total_elapsed_ms: totalElapsed,\n                avg_elapsed_ms: Math.round(results.reduce((a, r) => a + r.elapsed_ms, 0) / results.length)\n            }\n        }\n    };\n};"
}
