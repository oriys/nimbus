{
  "name": "http-fetch-python",
  "description": "HTTP client for fetching data from external APIs with retry and error handling",
  "runtime": "python3.11",
  "handler": "handler.handle",
  "memory_mb": 256,
  "timeout_sec": 60,
  "code": "import urllib.request\nimport urllib.parse\nimport urllib.error\nimport json\nimport time\nimport ssl\n\ndef handle(event, context):\n    \"\"\"Fetch data from HTTP endpoints.\n    \n    Parameters:\n    - url: Target URL (required)\n    - method: HTTP method (GET, POST, PUT, DELETE, PATCH)\n    - headers: Custom headers dict\n    - body: Request body (for POST/PUT/PATCH)\n    - query: Query parameters dict\n    - timeout: Request timeout in seconds\n    - retries: Number of retry attempts\n    - retry_delay: Delay between retries in seconds\n    - follow_redirects: Whether to follow redirects\n    - verify_ssl: Whether to verify SSL certificates\n    \"\"\"\n    url = event.get('url')\n    if not url:\n        return {\n            \"statusCode\": 400,\n            \"body\": {\"error\": \"url is required\"}\n        }\n    \n    method = event.get('method', 'GET').upper()\n    headers = event.get('headers', {})\n    body = event.get('body')\n    query = event.get('query', {})\n    timeout = event.get('timeout', 30)\n    retries = event.get('retries', 3)\n    retry_delay = event.get('retry_delay', 1)\n    verify_ssl = event.get('verify_ssl', True)\n    \n    # Add query parameters\n    if query:\n        separator = '&' if '?' in url else '?'\n        url = url + separator + urllib.parse.urlencode(query)\n    \n    # Prepare request body\n    data = None\n    if body:\n        if isinstance(body, dict):\n            data = json.dumps(body).encode('utf-8')\n            if 'Content-Type' not in headers:\n                headers['Content-Type'] = 'application/json'\n        else:\n            data = str(body).encode('utf-8')\n    \n    # Create SSL context\n    ssl_context = None\n    if not verify_ssl:\n        ssl_context = ssl.create_default_context()\n        ssl_context.check_hostname = False\n        ssl_context.verify_mode = ssl.CERT_NONE\n    \n    # Add default headers\n    if 'User-Agent' not in headers:\n        headers['User-Agent'] = 'Nimbus-Function/1.0'\n    \n    last_error = None\n    start_time = time.time()\n    \n    for attempt in range(retries):\n        try:\n            req = urllib.request.Request(url, data=data, headers=headers, method=method)\n            \n            with urllib.request.urlopen(req, timeout=timeout, context=ssl_context) as response:\n                response_body = response.read().decode('utf-8')\n                response_headers = dict(response.getheaders())\n                \n                # Try to parse as JSON\n                try:\n                    response_data = json.loads(response_body)\n                except json.JSONDecodeError:\n                    response_data = response_body\n                \n                return {\n                    \"statusCode\": 200,\n                    \"body\": {\n                        \"status\": response.status,\n                        \"headers\": response_headers,\n                        \"data\": response_data,\n                        \"url\": response.url,\n                        \"elapsed_ms\": int((time.time() - start_time) * 1000),\n                        \"attempts\": attempt + 1\n                    }\n                }\n                \n        except urllib.error.HTTPError as e:\n            error_body = e.read().decode('utf-8') if e.fp else None\n            try:\n                error_data = json.loads(error_body) if error_body else None\n            except:\n                error_data = error_body\n            \n            # Don't retry client errors (4xx)\n            if 400 <= e.code < 500:\n                return {\n                    \"statusCode\": e.code,\n                    \"body\": {\n                        \"error\": str(e.reason),\n                        \"status\": e.code,\n                        \"data\": error_data,\n                        \"elapsed_ms\": int((time.time() - start_time) * 1000)\n                    }\n                }\n            last_error = f\"HTTP {e.code}: {e.reason}\"\n            \n        except urllib.error.URLError as e:\n            last_error = f\"URL Error: {e.reason}\"\n            \n        except Exception as e:\n            last_error = f\"Error: {str(e)}\"\n        \n        if attempt < retries - 1:\n            time.sleep(retry_delay)\n    \n    return {\n        \"statusCode\": 500,\n        \"body\": {\n            \"error\": last_error,\n            \"attempts\": retries,\n            \"elapsed_ms\": int((time.time() - start_time) * 1000)\n        }\n    }"
}
