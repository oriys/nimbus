{
  "name": "json-transform-python",
  "description": "Complex JSON data transformation with filtering, mapping, and aggregation",
  "runtime": "python3.11",
  "handler": "handler.handle",
  "memory_mb": 256,
  "timeout_sec": 30,
  "code": "import json\nfrom functools import reduce\n\ndef handle(event, context):\n    \"\"\"Transform JSON data with various operations.\n    \n    Supported operations:\n    - filter: Filter items by condition (field, op, value)\n    - map: Transform items (extract fields or rename)\n    - sort: Sort by field (field, order: asc/desc)\n    - aggregate: Compute stats (sum, avg, min, max, count)\n    - group_by: Group items by field\n    \"\"\"\n    data = event.get('data', [])\n    operations = event.get('operations', [])\n    \n    result = data\n    \n    for op in operations:\n        op_type = op.get('type')\n        \n        if op_type == 'filter':\n            field = op.get('field')\n            operator = op.get('op', 'eq')\n            value = op.get('value')\n            \n            def filter_fn(item):\n                item_val = item.get(field)\n                if operator == 'eq': return item_val == value\n                if operator == 'ne': return item_val != value\n                if operator == 'gt': return item_val > value\n                if operator == 'gte': return item_val >= value\n                if operator == 'lt': return item_val < value\n                if operator == 'lte': return item_val <= value\n                if operator == 'contains': return value in str(item_val)\n                if operator == 'in': return item_val in value\n                return True\n            \n            result = list(filter(filter_fn, result))\n        \n        elif op_type == 'map':\n            fields = op.get('fields', [])\n            rename = op.get('rename', {})\n            \n            def map_fn(item):\n                if fields:\n                    new_item = {f: item.get(f) for f in fields if f in item}\n                else:\n                    new_item = item.copy()\n                for old_key, new_key in rename.items():\n                    if old_key in new_item:\n                        new_item[new_key] = new_item.pop(old_key)\n                return new_item\n            \n            result = list(map(map_fn, result))\n        \n        elif op_type == 'sort':\n            field = op.get('field')\n            order = op.get('order', 'asc')\n            result = sorted(result, key=lambda x: x.get(field, 0), reverse=(order == 'desc'))\n        \n        elif op_type == 'aggregate':\n            field = op.get('field')\n            agg_type = op.get('agg', 'count')\n            values = [item.get(field, 0) for item in result if field in item]\n            \n            if agg_type == 'sum':\n                agg_result = sum(values)\n            elif agg_type == 'avg':\n                agg_result = sum(values) / len(values) if values else 0\n            elif agg_type == 'min':\n                agg_result = min(values) if values else None\n            elif agg_type == 'max':\n                agg_result = max(values) if values else None\n            elif agg_type == 'count':\n                agg_result = len(values)\n            else:\n                agg_result = None\n            \n            return {\n                \"statusCode\": 200,\n                \"body\": {\n                    \"aggregation\": agg_type,\n                    \"field\": field,\n                    \"result\": agg_result,\n                    \"count\": len(values)\n                }\n            }\n        \n        elif op_type == 'group_by':\n            field = op.get('field')\n            groups = {}\n            for item in result:\n                key = str(item.get(field, 'null'))\n                if key not in groups:\n                    groups[key] = []\n                groups[key].append(item)\n            \n            return {\n                \"statusCode\": 200,\n                \"body\": {\n                    \"grouped_by\": field,\n                    \"groups\": groups,\n                    \"group_count\": len(groups)\n                }\n            }\n    \n    return {\n        \"statusCode\": 200,\n        \"body\": {\n            \"data\": result,\n            \"count\": len(result),\n            \"operations_applied\": len(operations)\n        }\n    }"
}
