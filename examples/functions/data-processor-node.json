{
  "name": "data-processor-node",
  "description": "Advanced data processing with validation, transformation, and statistics",
  "runtime": "nodejs20",
  "handler": "index.handler",
  "memory_mb": 256,
  "timeout_sec": 30,
  "code": "exports.handler = async (event, context) => {\n    const { data = [], schema, operations = [] } = event;\n    \n    // Validation\n    const validate = (items, schema) => {\n        if (!schema) return { valid: items, invalid: [] };\n        const valid = [];\n        const invalid = [];\n        \n        items.forEach((item, idx) => {\n            const errors = [];\n            for (const [field, rules] of Object.entries(schema)) {\n                const value = item[field];\n                if (rules.required && (value === undefined || value === null)) {\n                    errors.push(`${field} is required`);\n                }\n                if (rules.type && value !== undefined) {\n                    const actualType = Array.isArray(value) ? 'array' : typeof value;\n                    if (actualType !== rules.type) {\n                        errors.push(`${field} should be ${rules.type}, got ${actualType}`);\n                    }\n                }\n                if (rules.min !== undefined && value < rules.min) {\n                    errors.push(`${field} should be >= ${rules.min}`);\n                }\n                if (rules.max !== undefined && value > rules.max) {\n                    errors.push(`${field} should be <= ${rules.max}`);\n                }\n                if (rules.pattern && !new RegExp(rules.pattern).test(value)) {\n                    errors.push(`${field} doesn't match pattern`);\n                }\n            }\n            if (errors.length > 0) {\n                invalid.push({ index: idx, item, errors });\n            } else {\n                valid.push(item);\n            }\n        });\n        return { valid, invalid };\n    };\n    \n    // Statistics\n    const computeStats = (items, field) => {\n        const values = items.map(i => i[field]).filter(v => typeof v === 'number');\n        if (values.length === 0) return null;\n        \n        const sorted = [...values].sort((a, b) => a - b);\n        const sum = values.reduce((a, b) => a + b, 0);\n        const mean = sum / values.length;\n        const variance = values.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / values.length;\n        \n        return {\n            count: values.length,\n            sum,\n            mean: Math.round(mean * 100) / 100,\n            min: Math.min(...values),\n            max: Math.max(...values),\n            median: sorted.length % 2 === 0 \n                ? (sorted[sorted.length/2 - 1] + sorted[sorted.length/2]) / 2 \n                : sorted[Math.floor(sorted.length/2)],\n            stdDev: Math.round(Math.sqrt(variance) * 100) / 100\n        };\n    };\n    \n    // Process operations\n    let result = data;\n    const { valid, invalid } = validate(data, schema);\n    result = valid;\n    \n    const stats = {};\n    let grouped = null;\n    \n    for (const op of operations) {\n        switch (op.type) {\n            case 'deduplicate':\n                const seen = new Set();\n                result = result.filter(item => {\n                    const key = op.field ? item[op.field] : JSON.stringify(item);\n                    if (seen.has(key)) return false;\n                    seen.add(key);\n                    return true;\n                });\n                break;\n                \n            case 'enrich':\n                const { field, mapping, targetField } = op;\n                result = result.map(item => ({\n                    ...item,\n                    [targetField || `${field}_enriched`]: mapping[item[field]] || op.default || null\n                }));\n                break;\n                \n            case 'compute':\n                result = result.map(item => {\n                    const computed = {};\n                    for (const [name, expr] of Object.entries(op.fields || {})) {\n                        try {\n                            computed[name] = new Function('item', `return ${expr}`)(item);\n                        } catch (e) {\n                            computed[name] = null;\n                        }\n                    }\n                    return { ...item, ...computed };\n                });\n                break;\n                \n            case 'stats':\n                stats[op.field] = computeStats(result, op.field);\n                break;\n                \n            case 'pivot':\n                const { rowField, colField, valueField, aggFn = 'sum' } = op;\n                const pivot = {};\n                result.forEach(item => {\n                    const row = item[rowField];\n                    const col = item[colField];\n                    const val = item[valueField] || 0;\n                    if (!pivot[row]) pivot[row] = {};\n                    if (!pivot[row][col]) pivot[row][col] = aggFn === 'count' ? 0 : [];\n                    if (aggFn === 'count') {\n                        pivot[row][col]++;\n                    } else {\n                        pivot[row][col].push(val);\n                    }\n                });\n                if (aggFn !== 'count') {\n                    for (const row in pivot) {\n                        for (const col in pivot[row]) {\n                            const vals = pivot[row][col];\n                            pivot[row][col] = aggFn === 'sum' ? vals.reduce((a,b) => a+b, 0)\n                                : aggFn === 'avg' ? vals.reduce((a,b) => a+b, 0) / vals.length\n                                : vals;\n                        }\n                    }\n                }\n                grouped = { type: 'pivot', data: pivot };\n                break;\n        }\n    }\n    \n    return {\n        statusCode: 200,\n        body: {\n            data: grouped ? grouped.data : result,\n            metadata: {\n                inputCount: data.length,\n                outputCount: grouped ? Object.keys(grouped.data).length : result.length,\n                validationErrors: invalid.length,\n                invalidItems: invalid.slice(0, 10),\n                statistics: Object.keys(stats).length > 0 ? stats : undefined\n            }\n        }\n    };\n};"
}
